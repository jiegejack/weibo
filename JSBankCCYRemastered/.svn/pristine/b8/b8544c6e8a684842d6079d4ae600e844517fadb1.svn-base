//
//  LocationManager.m
//  JSBankCCYRemastered
//
//  Created by Jack on 2019/6/16.
//  Copyright © 2019 Jack. All rights reserved.
//

#import "LocationManager.h"
#import <CoreLocation/CoreLocation.h>

@interface LocationManager ()<CLLocationManagerDelegate>

/*定位相关*/
@property(nonatomic,strong) CLLocationManager *locationManager;

@property(nonatomic,strong) NSDictionary *locationDict;

@property(nonatomic,strong)CLLocation *location;

@property(nonatomic,copy) void (^locationBlock)(NSDictionary *location);

@end

@implementation LocationManager

-(NSDictionary *)locationDict
{
    if (!_locationDict)
    {
        _locationDict=[NSDictionary dictionary];
    }
    return _locationDict;
}

- (CLLocationManager *)locationManager {
    if (!_locationManager) {
        _locationManager=({
            CLLocationManager *locationManager =[[CLLocationManager alloc] init];
            locationManager.delegate=self;
            locationManager.desiredAccuracy = kCLLocationAccuracyBest;
            locationManager.distanceFilter = 100.0f;
            if (@available(iOS 8.0, *)) {
                [locationManager requestWhenInUseAuthorization];
            }
            locationManager;
        });
    }
    return _locationManager;
}

+(LocationManager *)shareInstance
{
    static LocationManager *locationModel = nil;
    static dispatch_once_t token;
    dispatch_once(&token, ^{
        locationModel = [[LocationManager alloc] init];
    });
    return locationModel;
}

- (id)init {
    if (self = [super init]) {
        self.locationDict = @{@"City"     : @"南京",
                              @"Latitude" : @"32.090513",
                              @"Longitude": @"118.876879"};;
    }
    return self;
}

#pragma mark -定位成功回调
-(void)locationComplete:(void (^)(NSDictionary *))complete
{
    self.locationBlock=complete;
    //返回一个默认的定位地址
//    self.locationBlock(self.locationDict);
    
    [self.locationManager startUpdatingLocation];
}

-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray<CLLocation *> *)locations {
    if (self.location == nil) {
        __weak typeof(self) weakSelf=self;
        [self.locationManager stopUpdatingLocation];
        CLLocation *newLocation=[locations lastObject];
        self.location = newLocation;
        CLGeocoder *geoCoder=[[CLGeocoder alloc]init];
        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray<CLPlacemark *> * _Nullable placemarks, NSError * _Nullable error)
         {
             if (placemarks != nil) {
                 CLPlacemark *placeMark=(CLPlacemark *)placemarks.firstObject;
                 NSString *latitude = [NSString stringWithFormat:@"%f",newLocation.coordinate.latitude];
                 NSString *longitude = [NSString stringWithFormat:@"%f",newLocation.coordinate.longitude];
                 NSString *city = placeMark.locality;
                 NSDictionary *locationDict = @{@"City"     : city,
                                                @"Latitude" : latitude,
                                                @"Longitude": longitude};
                 weakSelf.locationDict = locationDict;
                 weakSelf.locationBlock(weakSelf.locationDict);
             }
         }];
    }
    
}

- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error {
    [self.locationManager stopUpdatingLocation];
}

@end
