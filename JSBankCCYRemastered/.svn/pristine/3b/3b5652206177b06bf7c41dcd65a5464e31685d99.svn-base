//
//  TouchIDManager.m
//  TouchIDManager
//
//  Created by Jack on 2019/05/06.
//  Copyright © 2019年 TouchIDManager. All rights reserved.
//

#import "TouchIDManager.h"
#import "sys/utsname.h"
#import <UIKit/UIKit.h>
#import <LocalAuthentication/LocalAuthentication.h>

@implementation TouchIDManager

static LAErrorState _resultStatus;

+ (void)touchIDAuthenticateWithBackTitle:(NSString *)backTitle
                             cancelTitle:(NSString *)cancelTitle
                                  reason:(NSString *)reason
                                complete:(void(^)(void))complete
                                fiald:(void(^)(LAErrorState resultStatus))fiald {
    
    if ([self biometryType] == DJBiometryTypeNotSupport) {
        dispatch_async(dispatch_get_main_queue(), ^{
            if (fiald) {
                fiald(_resultStatus);
            }
        });
        return;
    }
    if (@available(iOS 8.0, *)) {
        LAContext* context = [[LAContext alloc] init];
        NSError* error = nil;
        reason = [self notNullString:reason] ? reason : @"生物验证!";
        if ([self notNullString:backTitle]) {
            context.localizedFallbackTitle = backTitle;
        }
        if ([self notNullString:cancelTitle]) {
            if (@available(iOS 10.0, *)) {
                context.localizedCancelTitle = cancelTitle;
            }
        }
        //首先使用canEvaluatePolicy判断设备否可用touchID
        __weak typeof(self) weakSelf = self;
        if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&error]) {
            [context evaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics localizedReason:reason reply:^(BOOL success, NSError *error) {
                if (success) {
                    dispatch_async(dispatch_get_main_queue(), ^{
                        if (fiald) {
                            fiald(LAErrorStateAuthenticateSuccess);
                        }
                    });
                } else {
                    dispatch_async(dispatch_get_main_queue(), ^{
                        [weakSelf touchIDHandleWithCode:error.code fiald:fiald];
                    });
                }
            }];
        } else {//指纹不可用
            dispatch_async(dispatch_get_main_queue(), ^{
                [weakSelf touchIDHandleWithCode:error.code fiald:fiald];
            });
        }
    }
}

+ (DJBiometryType)isSupportBiometryType {
    DJBiometryType type = DJBiometryTypeNotSupport;
    if (@available(iOS 8.0, *)) {
        LAContext *context = [[LAContext alloc] init];
        NSError *authError = nil;
        if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
            if (@available(iOS 11.0, *)) {
                if (context.biometryType == LABiometryTypeTouchID) {
                    type = DJBiometryTypeTouchID;
                } else if (context.biometryType == LABiometryTypeFaceID) {
                    type = DJBiometryTypeFaceID;
                }
            } else {
                NSError *authError = nil;
                if ([context canEvaluatePolicy:LAPolicyDeviceOwnerAuthenticationWithBiometrics error:&authError]) {
                    type = DJBiometryTypeTouchID;
                }
            }
        }
    }
    
    return type;
}

+ (DJBiometryType)biometryType {
#if TARGET_IPHONE_SIMULATOR
    _resultStatus = LAErrorStateSimulatorNotSupported;
    return DJBiometryTypeNotSupport;
#else
    if (@available(iOS 8.0, *)) {
        NSRange range = [[self platformInf] rangeOfString:@","];
        NSString *string = [[self platformInf] substringToIndex:range.location];
        
        NSRange finalRange = [string rangeOfString:@"iPhone"];
        NSString *finalResult = [string substringFromIndex:finalRange.length];
        
        if (finalResult.integerValue >= 6) {
            return [self isSupportBiometryType];
        }
        _resultStatus = LAErrorStateDeviceNotSupported;
        return DJBiometryTypeNotSupport;
    } else {
        _resultStatus = LAErrorStateSystemNotSupported;
        return DJBiometryTypeNotSupport;
    }
#endif
}

+ (void)touchIDHandleWithCode:(LAErrorState)code fiald:(void(^)(LAErrorState resultStatus))fiald {
    switch (code) {
        case LAErrorStateInputWrong:
            if (fiald) {
                fiald(LAErrorStateInputWrong);
            }
            break;
        case LAErrorStateUserCancel:
            if (fiald) {
                fiald(LAErrorStateUserCancel);
            }
            break;
        case LAErrorStateUsePassWord:
            if (fiald) {
                fiald(LAErrorStateUsePassWord);
            }
            break;
        case LAErrorStateSystemCancel:
            if (fiald) {
                fiald(LAErrorStateSystemCancel);
            }
            break;
        case LAErrorStateNotSetPassWord:
            if (fiald) {
                fiald(LAErrorStateNotSetPassWord);
            }
            break;
        case LAErrorStateNotAvailable:
            if (fiald) {
                fiald(LAErrorStateNotAvailable);
            }
            break;
        case LAErrorStateNotInputFinger:
            if (fiald) {
                fiald(LAErrorStateNotInputFinger);
            }
            break;
        case LAErrorStateLockout:
            if (fiald) {
                fiald(LAErrorStateLockout);
            }
            break;
        case LAErrorStateAppCancel:
            if (fiald) {
                fiald(LAErrorStateAppCancel);
            }
            break;
        case LAErrorStateCannotVerify:
            if (fiald) {
                fiald(LAErrorStateCannotVerify);
            }
            break;
        case LAErrorStateTouchIDNotSet:
            if (fiald) {
                fiald(LAErrorStateTouchIDNotSet);
            }
            break;
        default:
            break;
    }
}

+ (BOOL)notNullString:(NSString *)string {
    if (string == nil || string == NULL) {
        return NO;
    }
    if ([string isKindOfClass:[NSNull class]]) {
        return NO;
    }
    if ([[string stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]] length]==0) {
        return NO;
    }
    return YES;
}

+ (NSString *)platformInf {
    struct utsname systemInfo;
    uname(&systemInfo);
    return [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];
}

@end
