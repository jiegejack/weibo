//
//  InputContentView.m
//  JSBankCCYRemastered
//
//  Created by Jack on 2019/6/15.
//  Copyright © 2019 Jack. All rights reserved.
//

#import "InputContentView.h"

@interface InputContentView () <DoneDelegate,UITextFieldDelegate,instertWebviewTextDelegate>
@property (nonatomic, strong) NSMutableArray *items;
@property (nonatomic, assign) NSUInteger maxLength;
@property (nonatomic, assign) BOOL keyBoardShow;

@end
@implementation InputContentView

- (id)init {
    if (self = [super init]) {
        self.items = [NSMutableArray array];
        self.maxLength = 6;
        
        for (NSInteger index = 0; index < self.maxLength; index++) {
            UILabel *label = [[UILabel alloc] init];
//            label.backgroundColor = [UIColor greenColor];
            label.textAlignment = NSTextAlignmentCenter;
            label.font = [UIFont boldSystemFontOfSize:15];
            [self addSubview:label];
            [self.items addObject:label];
        }
        
        [self.items mas_distributeViewsAlongAxis:MASAxisTypeHorizontal withFixedSpacing:0 leadSpacing:0 tailSpacing:0];
        [self.items mas_makeConstraints:^(MASConstraintMaker *make) {
            make.top.mas_equalTo(self.mas_top);
            make.bottom.mas_equalTo(self.mas_bottom);
        }];
        
        self.layer.borderColor = [UIColor groupTableViewBackgroundColor].CGColor;
        self.layer.borderWidth = 1;
        
        UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(click)];
        [self addGestureRecognizer:tap];
    }
    return self;
}

- (void)drawRect:(CGRect)rect{
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGContextSetLineWidth(context, 1);
    CGContextSetStrokeColorWithColor(context, [UIColor groupTableViewBackgroundColor].CGColor);
    CGContextBeginPath(context);
    for (int i = 0; i < self.maxLength;  i++){
        CGContextMoveToPoint(context, self.frame.size.width/6.0 * (i + 1), 0);
        CGContextAddLineToPoint(context,self.frame.size.width/6.0 * (i + 1) , self.frame.size.height);
    }
    CGContextStrokePath(context);
}

- (void)click {
//    if (self.keyBoardShow) {
//        return;
//    }

//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyBoardWillHidden:) name:UIKeyboardWillHideNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyBoardWillShow:) name:UIKeyboardWillShowNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyBoardDidShow:) name:UIKeyboardDidShowNotification object:nil];
//    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyBoardDidHidden:) name:UIKeyboardWillShowNotification object:nil];
}

- (PassGuardTextField *)textField {
    if (!_textField) {
        _textField = [[PassGuardTextField alloc] init];
        [PassGuardTextField initPassGuardCtrl];
        _textField.textAlignment = NSTextAlignmentCenter;
        [_textField setM_license:Config().licence_kb];
        [_textField setM_mode:YES];//密码是否明文
        [_textField setM_hasstatus:NO];//按键状态
        [_textField setM_isEnablePaste:NO];//禁止粘贴
        [_textField setM_iMaxLen:6];
        [_textField setM_ikeypresstype:KEY_NONE_KEY_PRESS];
        [_textField setM_uiapp:[UIApplication sharedApplication]];
        _textField.randNumkb = self.keyboardType != UIKeyboardTypeDefault ? YES : NO;
        [_textField setM_ikeyordertype:self.keyboardType != UIKeyboardTypeDefault ? KEY_CHAOS_SWITCH_VIEW : KEY_NONE_CHAOS];
        [_textField setM_strInput1:KAESKey];
        _textField.translatesAutoresizingMaskIntoConstraints = NO;
        _textField.delegate = self;
        [_textField set_DoneDelegate:self];
        _textField.delegate = self;
        _textField.webdelegate=self;
        _textField.keyboardType = UIKeyboardTypeNumberPad;
        _textField.hidden = YES;
        [self addSubview:_textField];
    }
    
    return _textField;
}

-(void)instertWText {
    NSString *text = self.textField.text;
    if (text.length <= self.maxLength) {
        for (NSInteger index = 0; index < self.maxLength; index++) {
            UILabel *label = (UILabel *)self.items[index];
            
            if (index < text.length) {
                label.text = @"●";
            }
            else{
                label.text = @"";
            }
        }
        if (text.length == self.maxLength) {
            if (self.block) {
                self.block([self.textField getOutput1]);
            }
        }
    } else {
        self.textField.text = [text substringWithRange:NSMakeRange(0, self.maxLength)];
    }
}

- (void)keyBoardWillHidden:(NSNotification *)info {
//    self.keyBoardShow = NO;
//    self.userInteractionEnabled = YES;
//    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillHideNotification object:nil];
//    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil];
//    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidShowNotification object:nil];
}

- (void)keyBoardWillShow:(NSNotification *)info {
//    self.keyBoardShow = YES;
}

//- (void)keyBoardDidShow:(NSNotification *)info {
//    self.userInteractionEnabled = NO;
//}

//- (void)keyBoardDidHidden:(NSNotification *)info {
//    self.userInteractionEnabled = YES;
//}

-(void)DoneFun:(id)sender {
    if (self.textField.text.length < self.maxLength) {
        [self.textField resignFirstResponder];
        NSString *msg = [NSString stringWithFormat:@"交易密码不足%ld位,请重新输入",self.maxLength];
        [JSDeftAlert showMessage:msg afterDelay:1.5 completeHandle:nil];
    } else {
        if (self.block) {
            self.block([self.textField getOutput1]);
        }
    }
}

@end
