//
//  LocationManager.m
//  JSBankCCYRemastered
//
//  Created by Jack on 2019/6/16.
//  Copyright © 2019 Jack. All rights reserved.
//

#import "LocationManager.h"
#import <CoreLocation/CoreLocation.h>
#import <BMKLocationkit/BMKLocationComponent.h>

@interface LocationManager ()<BMKLocationManagerDelegate,BMKLocationAuthDelegate>
@property(nonatomic, strong) BMKLocationManager *locationManager;
@property(nonatomic, copy) BMKLocatingCompletionBlock completionBlock;

/*定位相关*/
//@property(nonatomic,strong) CLLocationManager *locationManager;

@property(nonatomic,strong) NSDictionary *locationDict;

@property(nonatomic,strong)CLLocation *location;

@property(nonatomic,copy) void (^locationBlock)(NSDictionary *location);

@end

@implementation LocationManager

-(NSDictionary *)locationDict
{
    if (!_locationDict)
    {
        _locationDict=[NSDictionary dictionary];
    }
    return _locationDict;
}

- (void)initLocationManager {
    if (!_locationManager) {
        //初始化实例
        _locationManager = [[BMKLocationManager alloc] init];
        //设置delegate
        _locationManager.delegate = self;
        //设置返回位置的坐标系类型
        _locationManager.coordinateType = BMKLocationCoordinateTypeBMK09LL;
        //设置距离过滤参数
        _locationManager.distanceFilter = kCLDistanceFilterNone;
        //设置预期精度参数
        _locationManager.desiredAccuracy = kCLLocationAccuracyBest;
        //设置应用位置类型
        _locationManager.activityType = CLActivityTypeAutomotiveNavigation;
        //设置是否自动停止位置更新
        _locationManager.pausesLocationUpdatesAutomatically = NO;
        //设置是否允许后台定位
//        _locationManager.allowsBackgroundLocationUpdates = YES;
        //设置位置获取超时时间
        _locationManager.locationTimeout = 10;
        //设置获取地址信息超时时间
        _locationManager.reGeocodeTimeout = 10;
        
    }
//    return _locationManager;
}

- (void)stopLocation {
//    if (_mapView) {
//        _mapView = nil;
//    }
    _locationManager = nil;
    _completionBlock = nil;
    
    [_locationManager stopUpdatingLocation];
    _locationManager.delegate = nil;
}

+(LocationManager *)shareInstance
{
    static LocationManager *locationModel = nil;
    static dispatch_once_t token;
    dispatch_once(&token, ^{
        locationModel = [[LocationManager alloc] init];
    });
    return locationModel;
}

- (id)init {
    if (self = [super init]) {
        self.locationDict = @{@"city"     : @"南京",
                              @"lat" : @"32.090513",
                              @"lng": @"118.876879"};
        
        [[BMKLocationAuth sharedInstance] checkPermisionWithKey:@"WPHk95CsVq6jWdOzAX7vZ9Rcn7uIy9gz" authDelegate:self];

    }
    return self;
}

#pragma mark -定位成功回调
-(void)locationComplete:(void (^)(NSDictionary *))complete
{
    [self initLocationManager];
    self.locationBlock=complete;
    //返回一个默认的定位地址
//    self.locationBlock(self.locationDict);
    
//    [self.locationManager startUpdatingLocation];
    [self.locationManager requestLocationWithReGeocode:YES withNetworkState:YES completionBlock:^(BMKLocation * _Nullable location, BMKLocationNetworkState state, NSError * _Nullable error) {
        //获取经纬度和该定位点对应的位置信息                }
        if (location.rgcData) {
            NSLog(@"rgc = %@",location.rgcData.cityCode);
            
        }
    }];
    self.completionBlock = ^(BMKLocation *location, BMKLocationNetworkState state, NSError *error)
    {
        if (error)
        {
            NSLog(@"locError:{%ld - %@};", (long)error.code, error.localizedDescription);
        }
        if (location) {//得到定位信息，添加annotation

            //                if (location.location) {
            //                    NSLog(@"LOC = %@",location.location);
            //                }
            if (location.rgcData) {
                NSLog(@"rgc = %@",location.rgcData.cityCode);

            }
        }
        NSLog(@"netstate = %d",state);
    };
}
- (void)BMKLocationManager:(BMKLocationManager * _Nonnull)manager doRequestAlwaysAuthorization:(CLLocationManager * _Nonnull)locationManager
{
    
    if (@available(iOS 8.0, *)) {
        [locationManager requestAlwaysAuthorization];
    } else {
        // Fallback on earlier versions
    }
}
//-(void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray<CLLocation *> *)locations {
//    if (self.location == nil) {
//        __weak typeof(self) weakSelf=self;
//        [self.locationManager stopUpdatingLocation];
//        CLLocation *newLocation=[locations lastObject];
//        self.location = newLocation;
//        CLGeocoder *geoCoder=[[CLGeocoder alloc]init];
//        [geoCoder reverseGeocodeLocation:newLocation completionHandler:^(NSArray<CLPlacemark *> * _Nullable placemarks, NSError * _Nullable error)
//         {
//             if (placemarks != nil) {
//                 CLPlacemark *placeMark=(CLPlacemark *)placemarks.firstObject;
//                 NSString *latitude = [NSString stringWithFormat:@"%f",newLocation.coordinate.latitude];
//                 NSString *longitude = [NSString stringWithFormat:@"%f",newLocation.coordinate.longitude];
//                 NSString *city = placeMark.locality;
//                 NSDictionary *locationDict = @{@"city"     : city,
//                                                @"lat" : latitude,
//                                                @"lng": longitude};
////                 NSLog(@"%@", placeMark.sub);
//                 weakSelf.locationDict = locationDict;
//                 weakSelf.locationBlock(weakSelf.locationDict);
//             }
//         }];
//    }
//
//}

//- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error {
//    [self.locationManager stopUpdatingLocation];
//}

@end
